// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ast = require("./Ast.bs.js");
var Token = require("./Token.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

function parse_factor(tokenList) {
  if (tokenList) {
    var remainingTokens = tokenList.tl;
    var token = tokenList.hd;
    if (Token.identificador(token) === "Negation" || Token.identificador(token) === "Bitwise" || Token.identificador(token) === "LogNeg") {
      var match = parse_factor(remainingTokens);
      var remainingTokens$1 = match[1];
      var fac = match[0];
      if (Ast.identi_factor(fac) === true) {
        return [
                {
                  TAG: /* UnOp */0,
                  _0: token,
                  _1: fac
                },
                remainingTokens$1
              ];
      } else {
        return [
                {
                  TAG: /* Err_fac */1,
                  _0: "Error, falta una constante u operador unario"
                },
                remainingTokens$1
              ];
      }
    }
    if (Token.identificador(token) !== "Constant") {
      return [
              {
                TAG: /* Err_fac */1,
                _0: "Error, a constant or unary operator is missing"
              },
              tokenList
            ];
    }
    var number = Caml_format.caml_int_of_string(Token.extrac(token));
    return [
            {
              TAG: /* Const */2,
              _0: number
            },
            remainingTokens
          ];
  }
  throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "ParserEnglish.re",
          2,
          6
        ],
        Error: new Error()
      };
}

exports.parse_factor = parse_factor;
/* No side effect */

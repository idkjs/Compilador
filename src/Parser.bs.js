// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ast$Nqcc = require("./Ast.bs.js");
var Token$Nqcc = require("./Token.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

function parse_factor(tokenList) {
  if (tokenList) {
    var remainingTokens = tokenList.tl;
    var token = tokenList.hd;
    if (Token$Nqcc.identificador(token) === "Negation" || Token$Nqcc.identificador(token) === "Bitwise" || Token$Nqcc.identificador(token) === "LogNeg") {
      var match = parse_factor(remainingTokens);
      var remainingTokens$1 = match[1];
      var fac = match[0];
      if (Ast$Nqcc.identi_factor(fac) === true) {
        return [
                {
                  TAG: /* UnOp */0,
                  _0: token,
                  _1: fac
                },
                remainingTokens$1
              ];
      } else {
        return [
                {
                  TAG: /* Err_fac */1,
                  _0: "Error, falta una constante u operador unario"
                },
                remainingTokens$1
              ];
      }
    }
    if (Token$Nqcc.identificador(token) !== "Constant") {
      return [
              {
                TAG: /* Err_fac */1,
                _0: "Error, falta una constante u operador unario"
              },
              tokenList
            ];
    }
    var number = Caml_format.caml_int_of_string(Token$Nqcc.extrac(token));
    return [
            {
              TAG: /* Const */2,
              _0: number
            },
            remainingTokens
          ];
  }
  throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "Parser.re",
          2,
          8
        ],
        Error: new Error()
      };
}

function parse_termino(tokenList) {
  var match = parse_factor(tokenList);
  var tokenList$1 = match[1];
  var fac1 = match[0];
  if (Ast$Nqcc.identi_factor(fac1) !== true) {
    return [
            {
              TAG: /* Err_ter */1,
              _0: Ast$Nqcc.ext_fac_err(fac1)
            },
            tokenList$1
          ];
  }
  if (tokenList$1) {
    var token = tokenList$1.hd;
    if (!(Token$Nqcc.identificador(token) === "Multiplication" || Token$Nqcc.identificador(token) === "Division")) {
      return [
              {
                TAG: /* Ter */0,
                _0: fac1
              },
              tokenList$1
            ];
    }
    var match$1 = parse_factor(tokenList$1.tl);
    var r = match$1[1];
    var fac2 = match$1[0];
    if (Ast$Nqcc.identi_factor(fac2) === true) {
      return [
              {
                TAG: /* BinOp */2,
                _0: token,
                _1: fac1,
                _2: fac2
              },
              r
            ];
    } else {
      return [
              {
                TAG: /* Err_ter */1,
                _0: Ast$Nqcc.ext_fac_err(fac1)
              },
              r
            ];
    }
  }
  throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "Parser.re",
          24,
          12
        ],
        Error: new Error()
      };
}

function parse_exp(tokenList) {
  var match = parse_termino(tokenList);
  var tokenList$1 = match[1];
  var ter1 = match[0];
  if (Ast$Nqcc.identi_termino(ter1) !== true) {
    return [
            {
              TAG: /* Err_exp */1,
              _0: Ast$Nqcc.ext_ter_err(ter1)
            },
            tokenList$1
          ];
  }
  if (tokenList$1) {
    var token = tokenList$1.hd;
    if (!(Token$Nqcc.identificador(token) === "Addition" || Token$Nqcc.identificador(token) === "Negation")) {
      return [
              {
                TAG: /* Expr */0,
                _0: ter1
              },
              tokenList$1
            ];
    }
    var match$1 = parse_termino(tokenList$1.tl);
    var r = match$1[1];
    var ter2 = match$1[0];
    if (Ast$Nqcc.identi_termino(ter2) === true) {
      return [
              {
                TAG: /* BinOp */2,
                _0: token,
                _1: ter1,
                _2: ter2
              },
              r
            ];
    } else {
      return [
              {
                TAG: /* Err_exp */1,
                _0: Ast$Nqcc.ext_ter_err(ter2)
              },
              r
            ];
    }
  }
  throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "Parser.re",
          45,
          12
        ],
        Error: new Error()
      };
}

function parse_statement(tokenList) {
  if (tokenList) {
    var remainingTokens = tokenList.tl;
    var token = tokenList.hd;
    if (Token$Nqcc.identificador(token) !== "ReturnKeyword") {
      return [
              {
                TAG: /* Err_state */2,
                _0: "Error, falta return"
              },
              remainingTokens
            ];
    }
    var $$var = Token$Nqcc.identificador(token);
    var match = parse_exp(remainingTokens);
    var remainingTokens$1 = match[1];
    var exp = match[0];
    if (Ast$Nqcc.identi_exp(exp) !== true) {
      return [
              {
                TAG: /* Err_state */2,
                _0: Ast$Nqcc.ext_exp_err(exp)
              },
              remainingTokens$1
            ];
    }
    if (remainingTokens$1) {
      var remainingTokens$2 = remainingTokens$1.tl;
      if (Token$Nqcc.identificador(remainingTokens$1.hd) === "Semicolon") {
        return [
                {
                  TAG: /* Assign */0,
                  _0: $$var,
                  _1: exp
                },
                remainingTokens$2
              ];
      } else {
        return [
                {
                  TAG: /* Err_state */2,
                  _0: "Error, falta ;"
                },
                remainingTokens$2
              ];
      }
    }
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "Parser.re",
            68,
            16
          ],
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "Parser.re",
          63,
          8
        ],
        Error: new Error()
      };
}

function parse_function(tokenList) {
  if (tokenList) {
    if (Token$Nqcc.identificador(tokenList.hd) !== "IntKeyword") {
      return {
              TAG: /* Err_fun */0,
              _0: "Error, falta int"
            };
    }
    var remainingTokens = tokenList.tl;
    if (remainingTokens) {
      var token = remainingTokens.hd;
      if (Token$Nqcc.identificador(token) !== "Id") {
        return {
                TAG: /* Err_fun */0,
                _0: "Error, falta identificador"
              };
      }
      var remainingTokens$1 = remainingTokens.tl;
      var idName = Token$Nqcc.extrac(token);
      if (remainingTokens$1) {
        if (Token$Nqcc.identificador(remainingTokens$1.hd) !== "OpenParen") {
          return {
                  TAG: /* Err_fun */0,
                  _0: "Error, falta ("
                };
        }
        var remainingTokens$2 = remainingTokens$1.tl;
        if (remainingTokens$2) {
          if (Token$Nqcc.identificador(remainingTokens$2.hd) !== "CloseParen") {
            return {
                    TAG: /* Err_fun */0,
                    _0: "Error, falta )"
                  };
          }
          var remainingTokens$3 = remainingTokens$2.tl;
          if (remainingTokens$3) {
            if (Token$Nqcc.identificador(remainingTokens$3.hd) !== "OpenBrace") {
              return {
                      TAG: /* Err_fun */0,
                      _0: "Error, falta {"
                    };
            }
            var match = parse_statement(remainingTokens$3.tl);
            var remainingTokens$4 = match[1];
            var $$return = match[0];
            if (Ast$Nqcc.identi_statement($$return) !== true) {
              return {
                      TAG: /* Err_fun */0,
                      _0: Ast$Nqcc.ext_state_err($$return)
                    };
            }
            if (remainingTokens$4) {
              if (Token$Nqcc.identificador(remainingTokens$4.hd) === "CloseBrace") {
                return {
                        TAG: /* Fun */1,
                        _0: idName,
                        _1: $$return
                      };
              } else {
                return {
                        TAG: /* Err_fun */0,
                        _0: "Error, falta }"
                      };
              }
            }
            throw {
                  RE_EXN_ID: "Match_failure",
                  _1: [
                    "Parser.re",
                    96,
                    32
                  ],
                  Error: new Error()
                };
          }
          throw {
                RE_EXN_ID: "Match_failure",
                _1: [
                  "Parser.re",
                  92,
                  24
                ],
                Error: new Error()
              };
        }
        throw {
              RE_EXN_ID: "Match_failure",
              _1: [
                "Parser.re",
                90,
                20
              ],
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "Parser.re",
              88,
              16
            ],
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "Parser.re",
            85,
            12
          ],
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "Parser.re",
          83,
          8
        ],
        Error: new Error()
      };
}

function parse_program(tokenList) {
  var func_decl = parse_function(tokenList);
  if (Ast$Nqcc.identi_fun_decl(func_decl) === true) {
    return {
            TAG: /* Prog */0,
            _0: func_decl
          };
  } else {
    console.log(Ast$Nqcc.ext_fun_err(func_decl));
    return {
            TAG: /* Err_prog */1,
            _0: "Error en el parser"
          };
  }
}

exports.parse_factor = parse_factor;
exports.parse_termino = parse_termino;
exports.parse_exp = parse_exp;
exports.parse_statement = parse_statement;
exports.parse_function = parse_function;
exports.parse_program = parse_program;
/* No side effect */
